# 🛠<span style="color:blue"> C / C++ 기술면접</span>
- <u>C vs C++</u>
    - C언어는 절차지향,순차적으로 처리
    - C++은 객체지향, 객체 중심으로 데이터와 메소드를 만들어 처리 > 캡슐화, 상속성과 같은 특징
---
- <u>C++ [***상속 & 다형성***]</u>
    - **상속** : 멤버 변수와 멤버 함수를 자식 클래스에 물려줌 <br> 부모 클래스의 모든 멤버들을 자식 클래스가 물려받는다. 재사용
    - **다형성** : 객체들의 타입이 다르면 똑같은 함수를 호출해도 서로 다른 동작을 하게 된다. 하나의 코드로 다양한 타입의 객체 처리
---
- <u>constructor(생성자), destructor(소멸자) ?</u>
    - **생성자**, 객체 생성될 때 자동 생성<br>생성자를 따로 구현하지 않는다면 객체를 생성할 때 멤버 변수가 NULL로 초기화 된다.<br> 매개 변수를 다르게 함으로써 중복 정의 가능 
    - **소멸자**, 객체 소멸될 때 자동 소멸<bR> 객체의 메모리 반환을 위해 사용, 클래스 이름 앞에 '~'가 붙은 형태
---
- <u>default constructor</u>
    - ***기본 생성자*** <br> 생성자가 없는 경우 컴파일러에 의해 자동 생성되는 생성자
---
- <u>Virtual, 함수 앞에 virtual을 붙이면 가상 함수가 된다.</u>
    - 상속에서 오버라이딩 할 때 사용<br>부모 클래스에서 선언한 함수가 자식 클래스에서 재정의할 것을 알려준다.
---
- <u>오버로딩과 오버라이딩</u>
    - 오버로딩 : 함수 중복 정의, 함수명이 같은 함수를 중복 정의<br>파라미터 개수, 파라미터의 자료형에 따라 여러개의 같은 이름의 함수를 만들 수 있다.
    - 오버라이딩 : 상속 관계에서 함수 재정의<br>상속받았을 때 클래스의 함수를 사용하지 않고 다른 기능 실행 시<br>함수를 자식클래스에 다른 이름, 같은 자료형으로 재정의해서 사용
---
- <u>malloc과 new의 차이?</u>
    - malloc C언어, new C++
    - malloc 함수, heap 영역에서 할당, 초기값 지정 불가능
    - new 연산자, dynamic memory에서 할당, 초기값 지정 가능
---
- <u>struct와 class의 차이는?</u>
    - struct에서는 기본 한정자가 public, class는 private
---
- <u>얕은 복사와 깊은 복사</u><br>객체 생성하고 초기화 시 멤버변수를 어떻게 초기화하느냐에 따라 구분
    -**얕은 복사**는 실제 데이터가 아닌 단지 메모리 주소만을 복사
    -**깊은 복사**는 변수가 관리하는 리소스 자체를 복사하여 새롭게 멤버 변수에 복사한다. <br>얕은 복사에 비해 작업 시간과 리소스의 소모가 따른다.
---
- <u>**C++ 프로그램 빌드(컴퓨터가 이해할 수 있도록 만드는) 과정**</u>
    - 전처리 -> 컴파일러 -> 어셈블러 -> 링커 
    1. 전처리 : 코드의 주석을 제거, define을 치환하는 기능
    2. 컴파일러 : 어셈블리 파일로 변환
    3. 어셈블러 : 오브젝트 파일로 변환, 오브젝트 코드는 0과1로 이루어진 코드
    4. 링커 : 오브젝트 파일들을 묶어 실행 코드파일로 변환한다.<br>운영체제가 로딩할 수 있도록 주소 정보를 할당한 파일을 만들어 낸다.<br>